{
  "hash": "60782f62c1ba9ebcbf1cc736b9936488",
  "result": {
    "markdown": "---\ntitle: \"9: MLM Assumptions\"\nparams: \n    SHOW_SOLS: FALSE\n    TOGGLE: TRUE\neditor_options: \n  chunk_output_type: console\n---\n\n\n\n\n\n:::lo\nThis reading:  \n\n- Multilevel model assumptions\n    - Random effects can be thought of as another level of residual \n- Case diagnostics in multilevel models\n    - influential observations and influential groups  \n- Optional Extra: Group confounding and the random effects assumption\n\n:::\n\n# MLM Assumptions & Diagnostics\n\nHopefully by now you are getting comfortable with the idea that all our models are simplifications, and so there is always going to be some difference between a model and real-life. This difference - the _residual_ - will ideally just be randomness, and we assess this by checking for systematic patterns in the residual term.  \n\nNot much is different in the multilevel model - we simply now have \"residuals\" on multiple levels. We are assuming that our group-level differences represent one level of randomness, and that our observations represent another level. We can see these two levels in @fig-lmmres, with the group-level deviations from the fixed effects ($\\color{orange}{\\zeta_{0i}}$ and $\\color{orange}{\\zeta_{1i}}$) along with the observation-level deviations from that groups line ($\\varepsilon_{ij}$).  \n\n\n::: {.cell layout-align=\"center\"}\n::: {.cell-output-display}\n![Multilevel model with group $i$ highlighted](images/un_lmm2.png){#fig-lmmres fig-align='center' width=100%}\n:::\n:::\n\n\n\n\n\nLet's suppose we are studying employee job satisfaction at the university. We have 399 employees from 25 different departments, and we got them to fill in a job satisfaction questionnaire, and got information on what their payscale was. We have also taken information from the national student survey on the level of student satisfaction for each department.  \n\nEach datapoint here represents an individual employee, and these employees are grouped into departments.  \n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nlibrary(tidyverse)\nlibrary(lme4)\njsuni <- read_csv(\"https://uoepsy.github.io/data/msmr_nssjobsat.csv\")\nhead(jsuni)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 6 × 5\n  NSSrating dept                                   payscale jobsat jobsat_binary\n      <dbl> <chr>                                     <dbl>  <dbl>         <dbl>\n1       4.8 International Public Health Policy            6     19             1\n2       6.7 Language Sciences                             8     17             0\n3       6.9 BSc Hons (Royal (Dick) Sch of Veterin…        7     17             0\n4       6.3 Veterinary Sciences                           7     16             0\n5       4.8 African Studies                               9     18             0\n6       4   Electronics                                   7     18             0\n```\n:::\n:::\n\n\nWe had a model that included by-participant random effects, such as:  \n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\njsmod <- lmer(jobsat ~ 1 + payscale + NSSrating + \n                (1 + payscale| dept), \n              data = jsuni)\n```\n:::\n\n\nThe equation for such a model would take the following form:  \n$$\n\\begin{align}\n\\text{For Employee }j\\text{ from Department }i& \\\\\n\\text{Level 1 (Employee):}& \\\\\n\\text{Stress}_{ij} &= b_{0i} + b_{1i} \\cdot \\text{Payscale}_{ij} + \\epsilon_{ij} \\\\\n\\text{Level 2 (Department):}& \\\\\nb_{0i} &= \\gamma_{00} + \\zeta_{0i} + \\gamma_{01} \\cdot \\text{NSSrating}_i\\\\\nb_{1i} &= \\gamma_{10} + \\zeta_{1i} \\\\\n& \\qquad \\\\\n\\text{Where:}& \\\\\n& \\begin{bmatrix} \\zeta_{0i} \\\\ \\zeta_{1i} \\end{bmatrix}\n\\sim N\n\\left(\n    \\begin{bmatrix} 0 \\\\ 0 \\end{bmatrix},\n    \\begin{bmatrix}\n        \\sigma_0 & \\rho_{01} \\\\\n        \\rho_{01} & \\sigma_1\n    \\end{bmatrix}\n\\right) \\\\\n& \\qquad \\\\\n& \\varepsilon_{ij} \\sim N(0,\\sigma_\\varepsilon)\n\\end{align}\n$$\n\nNote that this equation makes clear the distributional assumptions that our models make. It states the residuals $\\varepsilon$ are normally distributed with a mean of zero, and it says the same thing about our random effects!  \n\n\n## Level 1 residuals\n\nWe can get the level 1 (observation-level) residuals the same way we used to do for `lm()` - by just using `resid()` or `residuals()`.   Additionally, there are a few useful techniques for plotting these which we have listed below:  \n\n::::panelset\n:::panel\n#### resid vs fitted\n\nWe can plot the residuals vs fitted model (just like we used to for `lm()`), and assess the extend to which the assumption holds that the residuals are zero mean. \n_(we want the blue smoothed line to be fairly close to zero across the plot)_  \n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n# \"p\" below is for points and \"smooth\" for the smoothed line\nplot(jsmod, type=c(\"p\",\"smooth\"))\n```\n\n::: {.cell-output-display}\n![](09_assump_files/figure-html/unnamed-chunk-6-1.png){fig-align='center' width=80%}\n:::\n:::\n\n\n\n::: {.callout-caution collapse=\"true\"}\n#### residuals vs fitted plots will trend upwards\n\nAs a result of partial pooling, the residuals vs fitted plots will often tend to go upwards. \n\nIt's quite confusing to get your head around, but it is because the groups that are more outlying (which tend to have the lowest and highest fitted values, so they're on the left and right of the resid vs fitted plot) are the ones that get 'shrunk' more towards the center. So the fitted values will get pull towards the middle of the plot, but the residuals will get bigger (more negative for groups on below average, and more positive for groups above average). The result is that the entire plot tilts!  \n\nYou can see an animation of this in @fig-ppooltilt. The left hand plot shows the model fitted values for each group, with the residuals indicated by dashed lines. The right hand plots shows the residuals vs fitted plot. The animation moves between the 'no pooling' and 'partial pooling' approach, and as it does so, the plot on the right tilts!  \n\n\n::: {.cell layout-align=\"center\"}\n::: {.cell-output-display}\n![The effect of partial pooling on residuals vs fitted plots. The extent to which this tilting happens depends on the amount of shrinkage, so will be more evident when there are few observations in the groups](images/ppool_residfitted.gif){#fig-ppooltilt fig-align='center' width=80%}\n:::\n:::\n\n\n:::\n\n\n\n:::\n:::panel\n#### scale-location\n\nAgain, like we can for `lm()`, we can also look at a scale-location plot. This is where the square-root of the absolute value of the residuals is plotted against the fitted values, and allows us to more easily assess the assumption of constant variance.  \n_(we want the blue smoothed line to be close to horizontal across the plot)_  \n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nplot(jsmod,\n     form = sqrt(abs(resid(.))) ~ fitted(.),\n     type = c(\"p\",\"smooth\"))\n```\n\n::: {.cell-output-display}\n![](09_assump_files/figure-html/unnamed-chunk-8-1.png){fig-align='center' width=80%}\n:::\n:::\n\n\n:::\n:::panel\n#### facetted plots\n\nWe can also plot these \"resid v fitted\" and \"scale-location\" plots for each cluster, to check that our residual mean and variance is not related to the clusters:  \n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nplot(jsmod,\n         form = resid(.) ~ fitted(.) | dept,\n         type = c(\"p\"))\n```\n\n::: {.cell-output-display}\n![](09_assump_files/figure-html/unnamed-chunk-9-1.png){fig-align='center' width=80%}\n:::\n:::\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nplot(jsmod,\n         form = sqrt(abs(resid(.))) ~ fitted(.) | dept,\n         type = c(\"p\"))\n```\n\n::: {.cell-output-display}\n![](09_assump_files/figure-html/unnamed-chunk-10-1.png){fig-align='center' width=80%}\n:::\n:::\n\n    \n:::\n:::panel\n#### residual normality\n    \nWe can also examine the normality the level 1 residuals, using things such as histograms and QQplots:    \n_(we want the datapoints to follow close to the diagonal line)_  \n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nqqnorm(resid(jsmod)); qqline(resid(jsmod))\n```\n\n::: {.cell-output-display}\n![](09_assump_files/figure-html/unnamed-chunk-11-1.png){fig-align='center' width=80%}\n:::\n:::\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nhist(resid(jsmod))\n```\n\n::: {.cell-output-display}\n![](09_assump_files/figure-html/unnamed-chunk-12-1.png){fig-align='center' width=80%}\n:::\n:::\n\n\n\n:::\n::::\n\n## Level 2+ residuals\n\nThe second level of residuals in the multilevel model are actually just our random effects! We've seen them already whenever we use `ranef()`!  \n\nTo get out these we often need to do a bit of indexing. `ranef(model)` will give us a list with an item for each grouping. In each item we have a set of columns, one for each thing which is varying by that grouping.  \n\nBelow, we see that `ranef(jsmod)` gives us something with one entry, `$dept`, which contains 2 columns (the random intercepts and random slopes of `payscale`):  \n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nranef(jsmod)\n```\n:::\n\n```\n$dept\n                                        (Intercept)    payscale\nAccounting                              -0.03045458 -0.19259376\nArchitecture and Landscape Architecture  0.29419381 -0.35855884\nArt                                     -0.29094345  0.15293285\nBusiness Studies                        -0.27858102  0.18008149\n...                                      ...         ... \n```\n\nSo we can extract the random intercepts using `ranef(jsmod)$dept[,1]`.  \n\nAgain, we want normality of the random effects, so we can make more histograms or qqplots, for both the random intercepts and the random slopes:  \n\ne.g., for the random intercepts:  \n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nqqnorm(ranef(jsmod)$dept[,1]);qqline(ranef(jsmod)$dept[,1])\n```\n\n::: {.cell-output-display}\n![](09_assump_files/figure-html/unnamed-chunk-14-1.png){fig-align='center' width=80%}\n:::\n:::\n\n\nand for the random slopes:  \n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nqqnorm(ranef(jsmod)$dept[,2]);qqline(ranef(jsmod)$dept[,2])\n```\n\n::: {.cell-output-display}\n![](09_assump_files/figure-html/unnamed-chunk-15-1.png){fig-align='center' width=80%}\n:::\n:::\n\n\n## model simulations\n\nSometimes, a good global assessment of your model comes from how good a representation of the observed data it is. We can look at this in a cool way by simulating from our model a new set of values for the outcome. If we do this a few times over, and plot each 'draw' (i.e. set of simulated values), we can look at how well it maps to the observed set of values:  \n\nOne quick way to do this is with the `check_predictions()` function from the __performance__ package:  \n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nlibrary(performance)\ncheck_predictions(jsmod, iterations = 200)\n```\n\n::: {.cell-output-display}\n![](09_assump_files/figure-html/unnamed-chunk-16-1.png){fig-align='center' width=80%}\n:::\n:::\n\n\n::: {.callout-caution collapse=\"true\"}\n#### optional: doing it yourself\n\nDoing this ourselves gives us a lot more scope to query differences between our observed vs model-predicted data.  \n\nThe `simulate()` function will simulate response variable values for us.  \nThe `re.form = NULL` bit is saying to include the random effects when making simulations (i.e. use the information about the specific clusters we _have_ in our data). If we said `re.form = NA` it would base simulations on a randomly generated set of clusters with the associated intercept and slope variances estimated by our model.  \n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nmodsim <- simulate(jsmod, nsim = 200, re.form=NULL)\n```\n:::\n\nTo get this plotted, we'll have to do a bit of reworking, because it gives us a separate column for each draw. So if we pivot them longer we can make a density plot for each draw, and then add on top of that our observed scores:  \n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n# take the simulations\nmodsim |> \n  # pivot \"everything()\" (useful function to capture all columns),\n  # put column names into \"sim\", and the values into \"value\"\n  pivot_longer(everything(), names_to=\"sim\",values_to=\"value\") |>\n  # plot them! \n  ggplot(aes(x=value))+\n  # plot a different line for each sim. \n  # to make the alpha transparency work, i need to use\n  # geom_line(stat=\"density\") rather than \n  # geom_density() (for some reason alpha applies to fill here)\n  geom_line(aes(group=sim), stat=\"density\", alpha=.1,\n            col=\"darkorange\") +\n  # finally, add the observed scores!  \n  geom_density(data = jsuni, aes(x=jobsat), lwd=1)\n```\n\n::: {.cell-output-display}\n![](09_assump_files/figure-html/unnamed-chunk-18-1.png){fig-align='center' width=80%}\n:::\n:::\n\n\nHowever, we can also go further! We can pick a statistic, let's use the IQR, and see how different our observed IQR is from the IQRs of a series of simulated draws.  \n\nHere are 1000 simulations. This time I don't care about simulating for these specific clusters, I just want to compare to random draws of clusters:  \n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nsims <- simulate(jsmod, nsim=1000, re.form=NA)\n```\n:::\n\n\nThe `apply()` function (see also `lapply`, `sapply` ,`vapply`, `tapply`) is a really nice way to take an object, and apply a function to it. \nThe number 2 here is to say \"do it on each column\". If we had 1 it would be saying \"do it on each row\".  \nThis gives us the IQR of each simulation:\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nsimsIQR <- apply(sims, 2, IQR)\n```\n:::\n\n\nWe can then ask what proportion of our simulated draws have an IQR smaller than our observed IQR? If the answer is very big or very small it indicates our model does not very represent this part of reality very well.  \n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nmean(IQR(jsuni$jobsat)>simsIQR)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 0.451\n```\n:::\n:::\n\n\n:::\n\n<div class=\"divider div-transparent div-dot\"></div>\n\n# Influence\n\nJust like individual observations can exert influence on a single level linear model fitted with `lm()`, they can influence our multilevel models too. Just like our assumptions now apply at multiple levels, influence can happen at multiple levels too.  \n\nAn individual observation might influence our model (as in @fig-infl1), but so might an entire cluster (@fig-infl2).  \n\n:::: {.columns}\n:::{.column width=\"47.5%\"}\n\n\n::: {.cell layout-align=\"center\"}\n::: {.cell-output-display}\n![Dashed lines show fixed effects from (black line) model with the highlighted red observation, and (red line) model without the highlighted red observation.](09_assump_files/figure-html/fig-infl1-1.png){#fig-infl1 fig-align='center' width=80%}\n:::\n:::\n\n\n:::\n:::{.column width=\"5%\"}\n:::\n:::{.column width=\"47.5%\"}\n\n\n::: {.cell layout-align=\"center\"}\n::: {.cell-output-display}\n![Dashed lines show fixed effects from (black line) model with the highlighted group, and (red line) model without the highlighted group.](09_assump_files/figure-html/fig-infl2-1.png){#fig-infl2 fig-align='center' width=80%}\n:::\n:::\n\n\n:::\n::::\n\nThere are two main packages for examining influence in multilevel models, __HLMdiag__ and __influence.ME__ that work by going through and deleting each observation/cluster and examining how much things change. __HLMdiag__ works for `lmer()` but not `glmer()`, but provides a one-step approximation of the influence, which is often quicker than the full refitting process. The __influence.ME__ package will be slower, but works for both `lmer()` and `glmer()`.    \n\n::::panelset\n:::panel\n#### HLMdiag\n\nWe use this package by creating an object using `hlm_influence()`, specifying the level at which we want to examine influence.  \nIn this case, `level = 1` means we are looking at the influence of individual observations, and `level = \"dept\"` specifies that we are looking at the influence of the levels in the `dept` variable.  \nThe `approx = TRUE` part means that we are asking for the approximate calculations of influence measures, rather than asking for it to actually iteratively delete each observation and re-fit the model.  \n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nlibrary(HLMdiag)\ninf1 <- hlm_influence(model = jsmod, level = 1, approx = TRUE)\ninf2 <- hlm_influence(model = jsmod, level = \"dept\", approx = TRUE)\n```\n:::\n\n\nWe can then plot metrics such as the cooks distance for each of these. Note that the \"internal\" cutoff here adds a red line to the plots, and is simply calculated as the 3rd quartile plus 3 times the IQR, thereby capturing a relative measure of outlyingness.  \nAs with the measures of influence for `lm()`, such cutoffs are somewhat arbitrary, and so should be interpreted with caution.  \n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ndotplot_diag(inf1$cooksd, cutoff = \"internal\")\n```\n\n::: {.cell-output-display}\n![](09_assump_files/figure-html/unnamed-chunk-25-1.png){fig-align='center' width=80%}\n:::\n\n```{.r .cell-code}\ndotplot_diag(inf2$cooksd, \n             index = inf2$dept, cutoff = \"internal\")\n```\n\n::: {.cell-output-display}\n![](09_assump_files/figure-html/unnamed-chunk-25-2.png){fig-align='center' width=80%}\n:::\n:::\n\n\n\n:::\n:::panel\n#### influence.ME\n\nWe use this package by creating an object using `influence()`, specifying the level at which we want to examine influence.  \nIn this case, `obs = TRUE` means we are looking at the influence of individual observations, and `group = \"dept\"` specifies that we are looking at the influence of the levels in the `dept` variable.  \n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nlibrary(influence.ME)\ninf1 <- influence(model = jsmod, obs = TRUE)\ninf2 <- influence(model = jsmod, group = \"dept\")\n```\n:::\n\n\nWe can then plot metrics such as the cooks distance for each of these:\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nplot(inf1, which = \"cook\", sort=TRUE)\n```\n\n::: {.cell-output-display}\n![](09_assump_files/figure-html/unnamed-chunk-27-1.png){fig-align='center' width=80%}\n:::\n\n```{.r .cell-code}\nplot(inf2, which = \"cook\", sort=TRUE)\n```\n\n::: {.cell-output-display}\n![](09_assump_files/figure-html/unnamed-chunk-27-2.png){fig-align='center' width=80%}\n:::\n:::\n\n\n:::\n::::\n\nTo conduct a sensitivity analysis of our models robustness to the inclusion of such influential observations, we would simply fit our model with and without that observation/cluster, and examine if/how our conclusions would change.  \nFor instance, to refit our model without employees of the 'Nursing Studies' department: \n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\njsmod_NS <- lmer(jobsat ~ 1 + payscale + NSSrating + \n                (1 + payscale| dept), \n              data = jsuni |> \n                filter(dept!=\"Nursing Studies\"))\n```\n:::\n\nThe `tidy()` function from __broom.mixed__ is a quick way to print out parameters from each model:  \n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ntidy(jsmod)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 7 × 6\n  effect   group    term                      estimate std.error statistic\n  <chr>    <chr>    <chr>                        <dbl>     <dbl>     <dbl>\n1 fixed    <NA>     (Intercept)                 14.5      0.998      14.6 \n2 fixed    <NA>     payscale                     0.336    0.0800      4.21\n3 fixed    <NA>     NSSrating                    0.428    0.132       3.25\n4 ran_pars dept     sd__(Intercept)              0.934   NA          NA   \n5 ran_pars dept     cor__(Intercept).payscale   -0.494   NA          NA   \n6 ran_pars dept     sd__payscale                 0.294   NA          NA   \n7 ran_pars Residual sd__Observation              1.02    NA          NA   \n```\n:::\n\n```{.r .cell-code}\ntidy(jsmod_NS)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 7 × 6\n  effect   group    term                      estimate std.error statistic\n  <chr>    <chr>    <chr>                        <dbl>     <dbl>     <dbl>\n1 fixed    <NA>     (Intercept)                 15.4      0.999      15.5 \n2 fixed    <NA>     payscale                     0.324    0.0806      4.02\n3 fixed    <NA>     NSSrating                    0.318    0.132       2.42\n4 ran_pars dept     sd__(Intercept)              0.516   NA          NA   \n5 ran_pars dept     cor__(Intercept).payscale   -0.594   NA          NA   \n6 ran_pars dept     sd__payscale                 0.292   NA          NA   \n7 ran_pars Residual sd__Observation              1.02    NA          NA   \n```\n:::\n:::\n\n\n<div class=\"divider div-transparent div-dot\"></div>\n\n# Optional Extra: The DHARMa Package\n\n__DHARMa__ is a cool package that attempts to construct easy to interpret residuals for models of various families (allowing us to construct useful plots to look at for binomial and poisson models fitted with `glmer()`). \n\nIt achieves this by doing lots of simulated draws from the model, and for each observation $i$ it asks where the actual value falls in relation to the simulated values for that observation (i.e. that combination of predictors). If the observed is exactly what we would expect, it would fall right in the middle taking a value of 0.5 (0.5 of the simulated distribution for observation $i$ will be below and 0.5 will be below). If all the simulated values fall below the observed value, it would take the value 1. The DHARMa package has a good explanation of how this works in more detail ([https://cran.r-project.org/web/packages/DHARMa/vignettes/DHARMa.html](https://cran.r-project.org/web/packages/DHARMa/vignettes/DHARMa.html){target=\"_blank\"}), but it can be done for `lmer()`, `glmer()` and more.  \n\nHere's a binomial logistic model, where instead of a job-satisfaction _score_, we have a simple yes/no for job satisfaction:   \n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\njsmod2 <- glmer(jobsat_binary ~ 1 + payscale + NSSrating + \n                  (1 + payscale | dept), \n                data = jsuni, family=binomial)\n```\n:::\n\n\nThe DHARMa package works by first getting the simulated residuals\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nlibrary(DHARMa)\nmsim <- simulateResiduals(fittedModel = jsmod2)\n```\n:::\n\n\nIf our model is correctly specified, then the DHARMa residuals we would expect to be uniform (i.e. flat), and also uniform distributed across any predictor.  \n\nIt offers some nice ways to assess this, by plotting the observed vs expected distribution on a QQplot:  \n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nplotQQunif(msim)\n```\n\n::: {.cell-output-display}\n![](09_assump_files/figure-html/unnamed-chunk-32-1.png){fig-align='center' width=80%}\n:::\n:::\n\n\nAnd it plots the residuals against the fitted, while adding lines for quantiles of the distribution. If the middle one is flat, it equates to the \"zero mean\" assumption, and if the outer two are flat it equates to our \"constant variance\" assumption.  \n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nplotResiduals(msim)\n```\n\n::: {.cell-output-display}\n![](09_assump_files/figure-html/unnamed-chunk-33-1.png){fig-align='center' width=80%}\n:::\n:::\n\n\nWe can also plot the residuals against specific predictors:\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nplotResiduals(msim, form = jsuni$NSSrating)\n```\n\n::: {.cell-output-display}\n![](09_assump_files/figure-html/unnamed-chunk-34-1.png){fig-align='center' width=80%}\n:::\n:::\n\n\n\n<div class=\"divider div-transparent div-dot\"></div>\n\n# Optional Extra: Group confounding and the random effects assumption\n\nIn terms of our model equation (below for the random intercepts only model), the assumptions underlying our ability to generalise from these models are that both the residuals $\\varepsilon$ and the random effects $\\zeta_0$ are normally distributed with a mean of zero across the predictors of the model.  \n\n$$\n\\begin{align}\n\\text{For observation }j&\\text{ in cluster }i \\\\\n\\text{Level 1:}& \\\\\ny_{ij} &= b_{0i} + b_{1} \\cdot x_{ij} + \\varepsilon_{ij} \\\\\n\\text{Level 2:}& \\\\\nb_{0i} &= \\gamma_{00} + \\zeta_{0i} \\\\\n& \\qquad \\\\\n\\text{Where: }& \\\\\n&\\zeta_{0i} \\sim N(0,\\sigma_0) \\\\\n&\\varepsilon_{ij} \\sim N(0,\\sigma_\\varepsilon) \\\\\n\\end{align}\n$$\n\nAs with a single level regression in `lm()`, we don't want residuals that co-vary with predictors, but we also don't want random effects that co-vary with predictors. \nThis is a tricky notion to get one's head around. If we want to estimate the effect of x on y, then a simple linear regression model using `lm()` could be conceptualised as a diagram in @fig-conflmm1, where the arrows show the theoretical flow of information between variables, which are in squares and circles (the circle is used for the error term to show that it is a theorised underlying distribution that we don't directly observe, whereas the variables x and y are directly measured, and so presented in squares).  \n\n\n::: {.cell layout-align=\"center\"}\n::: {.cell-output-display}\n![A simple regression lm(y~x) in the form of a diagram. Observed variables are in squares, and unobserved variables that get estimated (in this case, the error) are in ovals. Arrows represent theorized flow of information.](images/endogeneity/Slide1.PNG){#fig-conflmm1 fig-align='center' width=80%}\n:::\n:::\n\n\nIn any model that we *actually fit to a sample*, the residuals we calculate will be uncorrelated with the predictor variable (as in @fig-conflmm1). The assumption we make, however, is *about the population*. \n\nIf the underlying way in which the data was generated (i.e. the population we are sampling from) has some relationship between the error and the predictor, and we fail to model this, then our estimated effect will be biased. For instance, in @fig-conflmm2, the model in orange would be biased because the true way in which the data was generated (in grey) is not accounted for. We would end up banning ice cream in order to stop shark attacks! \n\n\n::: {.cell layout-align=\"center\"}\n::: {.cell-output-display}\n![An example in which fitting a simple regression lm(shark_attacks ~ ice_cream_sales) would be biased. While the calculated residuals would not covary with our observed predictor, the two are correlated in the underlying population model.](images/endogeneity/Slide3.PNG){#fig-conflmm2 fig-align='center' width=80%}\n:::\n:::\n\n\nThe same is true in our multilevel model. In @fig-conflmm3 we can see that we have _two_ sources of error: the observation level, and the cluster level. The assumption we make is that in the true 'data generating process' there is no covariance between predictors and either error term. This sometimes get referred to as the \"random effects assumption\" or the \"endogeneity/exogeneity assumption\".^[\"endogeneity\" is a term used to refer to variables that are influenced by other variables in a system. In the multilevel model, the predictors are assumed to be 'exogenous' (i.e. not influenced by anything)]  \n\n::: {.cell layout-align=\"center\"}\n::: {.cell-output-display}\n![In the multilevel model, we have two sources of error (observations and clusters), both of which we assume are unrelated to our predictors](images/endogeneity/Slide4.PNG){#fig-conflmm3 fig-align='center' width=80%}\n:::\n:::\n\n\n\n::: {.callout-note collapse=\"true\"}\n#### other models\n\nThis is an assumption that we do _not_ have to make with our 'no pooling' model of `lm(y ~ cluster + x)`, because by putting the cluster in as another predictor we include the covariance between it and our predictor of interest (@fig-conflmm4). \n\n\n::: {.cell layout-align=\"center\"}\n::: {.cell-output-display}\n![The 'fixed effect' model of lm(y~cluster+x) does not have the issue of assuming clusters are unrelated to the predictor](images/endogeneity/Slide6.PNG){#fig-conflmm4 fig-align='center' width=80%}\n:::\n:::\n\n\n:::\n\nIn some cases, this assumption might not hold! For instance, if we are interested in whether drinking more alcohol is associated with more/less anxiety, and we had a model such `lmer(anxiety ~ alcohol + (1 | person))`, then our random effects (\"persons\") are likely associated with different drinking habits, as in @fig-conflmm5.  \n\n\n::: {.cell layout-align=\"center\"}\n::: {.cell-output-display}\n![In cases where our predictor is not directly manipulated as part of an experiment, it is quite possible to have some association between the random effects and the predictor. Our model lmer(anxiety ~ alcohol + (1 | person)) could produce a biased estimate of the relationship between alcohol and anxiety.](images/endogeneity/Slide7.PNG){#fig-conflmm5 fig-align='center' width=80%}\n:::\n:::\n\n\nOne option here is to include people's average alcohol consumption in as a fixed predictor, which removes the part of the random effect that is correlated with our predictor of interest, and models it explicitly. We will see more about this the next [Chapter on centering](10_centering.html){target=\"_blank\"}, and how it separates out two different associations.  \n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nlmer(anxiety ~ alcohol + avg_alcohol + (1 | person))\n```\n:::\n\n::: {.cell layout-align=\"center\"}\n::: {.cell-output-display}\n![Including person's average X as a fixed predictor removes that bias from the estimate of x on y](images/endogeneity/Slide8.PNG){#fig-conflmm6 fig-align='center' width=80%}\n:::\n:::\n",
    "supporting": [
      "09_assump_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {
      "include-in-header": [
        "<link href=\"site_libs/panelset-0.3.0/panelset.css\" rel=\"stylesheet\" />\r\n<script src=\"site_libs/panelset-0.3.0/panelset.js\"></script>\r\n"
      ]
    },
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}