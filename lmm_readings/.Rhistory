#| fig-cap: "Contour plot for a non-normal bivariate distribution. Marginal distributions of each variable are presented along each axis"
#| echo: false
p1 <- ggplot(d,aes(x=V1,y=V2))+
geom_point(alpha=.2)+
geom_density_2d()
ggExtra::ggMarginal(p1, type="histogram")
# Chunk 10
#| echo: false
cov(d[,1:2])
# Chunk 11: fig-bivsim
#| echo: false
#| label: fig-bivsim
#| fig-cap: "Probability distribution of simulations based on a covariance matrix (of some skewed variables). The covariance matrix contains only 2 'moments' of the variables: their scale (spread) and location (center)"
#| out-width: "100%"
#| out-height: "300px"
d <- as.data.frame(mvtnorm::rmvnorm(n = 1e3, mean = apply(d,2,mean)[1:2], sigma = cov(d[,1:2])))
d$density <- mvtnorm::dmvnorm(x = d)
plot_ly(d, x = ~ V1, y = ~ V2, z = ~ density,
marker = list(color = ~ density,
showscale = TRUE)) |>
add_markers()
# Chunk 12: fig-bivnon2
#| label: fig-bivnon2
#| fig-cap: "Contour plot for simulated data from a covariance matrix"
#| echo: false
p1 <- ggplot(d,aes(x=V1,y=V2))+
geom_point(alpha=.2)+
geom_density_2d()
ggExtra::ggMarginal(p1, type="histogram")
# Chunk 13
#| code-fold: true
library(kableExtra)
# this is just describe() but dressed up to make a nice table output (the one we see below)
stress_IQ_data |>
select(contains("IQ")) |>
describe() |>
as.data.frame() |>
rownames_to_column(var = "variable") |>
select(variable,mean,sd,skew,kurtosis) |>
kable(digits = 2) |>
kable_styling(full_width = FALSE)
# Chunk 14
stress_IQ_data |>
select(contains("IQ")) |>
multi.hist()
# Chunk 15
## GGPLOT
# temporarily reshape the data to long format to make it quicker to plot
stress_IQ_data |>
pivot_longer(IQ1:IQ5, names_to="variable",values_to="score") |>
ggplot(aes(x=score))+
geom_density()+
facet_wrap(~variable)+
theme_light()
# Chunk 16: robust estimator
model_IQ <- 'IQ =~ IQ1 + IQ2 + IQ3 + IQ4 + IQ5'
model_IQ.est <- cfa(model_IQ, data=stress_IQ_data, estimator='MLR')
# Chunk 17
fitmeasures(model_IQ.est)[c("rmsea","srmr","cfi","tli")]
# Chunk 18: check mods
modindices(model_IQ.est, sort=T) |> head()
# Chunk 19: make modifications
model2_IQ <- '
IQ=~IQ1+IQ2+IQ3+IQ4+IQ5
IQ1~~IQ2
IQ4~~IQ5
'
model2_IQ.est <- cfa(model2_IQ, data=stress_IQ_data, estimator='MLR')
# Chunk 20
fitmeasures(model2_IQ.est)[c("rmsea","srmr","cfi","tli")]
summary(model2_IQ.est, standardized=T)
# Chunk 21: fig-polychor
#| echo: false
#| label: fig-polychor
#| fig-cap: "the idea of polychoric correlation is to estimate the correlation between two unobserved continuous variables by examining the distributions across the set of ordered categories that we *do* observe"
set.seed(444)
df <- tibble(
item1 = rnorm(1e3),
item2 = .6*item1 + rnorm(1e3)
)
df <- as.data.frame(apply(df,2,scale))
df2 <- apply(df,2,function(x) cut(x,3,labels=c("disagree","neither","agree")))
names(df) <- paste0("l",names(df))
df <- cbind(df,df2)
thresh1 <- df |> group_by(item1) |>
summarise(
min = min(litem1),
max = max(litem1),
lab = max-((max-min)/2)
)
thresh2 <- df |> group_by(item2) |>
summarise(
min = min(litem2),
max = max(litem2),
lab = max-((max-min)/2)
)
ggplot(df,aes(x=litem1,y=litem2,col=interaction(item1,item2)))+
geom_point(size=3,alpha=.5)+
guides(col="none") +
geom_vline(data=thresh1[-2,], aes(xintercept=min))+
geom_hline(data=thresh2[-2,], aes(yintercept=min))+
geom_text(data=thresh1,inherit.aes=F,aes(x=lab,y=-3,label=item1))+
geom_text(data=thresh2,inherit.aes=F,aes(y=lab,x=-3.3,label=item2),angle=90)+
labs(x="underlying agreement with item 1",
y="underlying agreement with item 2")
# Chunk 22: categorical estimation
library(lavaan)
library(semPlot)
# specify the model
model_stress <- 'Stress =~ stress1 + stress2 + stress3 + stress4 + stress5'
# estimate the model - cfa will automatically switch to a categorical estimator if we mention that our five variables are ordered-categorical, using the 'ordered' function
model_stress.est <-
cfa(model_stress, data=stress_IQ_data,
ordered=c('stress1','stress2','stress3','stress4','stress5'))
# Chunk 23
# inspect the output
fitmeasures(model_stress.est)[c("rmsea","srmr","cfi","tli")]
summary(model_stress.est, standardized=TRUE)
# Chunk 24: full SEM
SEM_model <- '
#IQ measurement model
IQ =~ IQ1 + IQ2 + IQ3 + IQ4 + IQ5
IQ1 ~~ IQ2
IQ4 ~~ IQ5
#stress measurement model
Stress =~ stress1 + stress2 + stress3 + stress4 + stress5
#structural part of model
IQ ~ Stress
'
m1 <- sem(SEM_model, data=stress_IQ_data,
ordered=c('stress1','stress2','stress3','stress4','stress5'),
estimator="WLSMV")
m2 <- sem(SEM_model, data=stress_IQ_data,
ordered=c('stress1','stress2','stress3','stress4','stress5'),
estimator="WLSMV")
parameterEstimates(m1)
parameterEstimates(m2)
all.equal(parameterEstimates(m1),
parameterEstimates(m2)
)
m1 <- sem(SEM_model, data=stress_IQ_data,
ordered=c('stress1','stress2','stress3','stress4','stress5'),
estimator="WLSMV")
m2 <- sem(SEM_model, data=stress_IQ_data,
ordered=c('stress1','stress2','stress3','stress4','stress5'),
estimator="DWLS")
all.equal(parameterEstimates(m1),
parameterEstimates(m2)
)
parameterEstimates(m1)
cbind(parameterEstimates(m1)$se,
parameterEstimates(m2)$se)
cbind(parameterEstimates(m1),
parameterEstimates(m2))
parameterEstimates(m1)
parameterEstimates(m2)
summary(m1)
summary(m2)
m1 <- sem(SEM_model, data=stress_IQ_data,
ordered=c('stress1','stress2','stress3','stress4','stress5'),
estimator="WLSMV", se="bootstrap",boot=10)
m1 <- sem(SEM_model, data=stress_IQ_data,
ordered=c('stress1','stress2','stress3','stress4','stress5'),
estimator="WLSMV", se="bootstrap")
m1 <- sem(SEM_model, data=stress_IQ_data,
ordered=c('stress1','stress2','stress3','stress4','stress5'),
estimator="DWLS", se="bootstrap")
fitmeasures(model_IQ.est)
fitmeasures(model_IQ.est)[c("rmsea.robust","srmr","cfi.robust","tli.robust")]
# Chunk 1: setup
#| label: setup
#| include: false
source('assets/setup.R')
library(xaringanExtra)
library(tidyverse)
library(patchwork)
xaringanExtra::use_panelset()
qcounter <- function(){
if(!exists("qcounter_i")){
qcounter_i <<- 1
}else{
qcounter_i <<- qcounter_i + 1
}
qcounter_i
}
library(psych)
library(semPlot)
library(lavaan)
# Chunk 2
#| echo: false
tibble(
variable = names(read_csv("https://uoepsy.github.io/data/stressIQ.csv")),
description = c("Participant ID",
"acute stress",
"chronic stress",
"environmental stress",
"psychological stress",
"physiological stress",
"verbal ability",
"verbal memory",
"inductive reasoning",
"spatial orientiation",
"perceptual speed")
) |> gt::gt()
# Chunk 3
diagmod <- '
#IQ measurement model
IQ=~IQ1+IQ2+IQ3+IQ4+IQ5
#stress measurement model
Stress=~stress1+stress2+stress3+stress4+stress5
#structural part of model
IQ~Stress'
semPlot::semPaths(lavaanify(diagmod),rotation=1)
# Chunk 4
library(tidyverse)
library(psych)
stress_IQ_data <- read_csv("https://uoepsy.github.io/data/stressIQ.csv")
# Chunk 5
describe(stress_IQ_data) # from psych package
# Chunk 6
multi.hist(stress_IQ_data, global = FALSE) # from psych package
# Chunk 7: fig-bivnorm
#| echo: false
#| label: fig-bivnorm
#| fig-cap: "Bivariate Normal"
#| out-width: "100%"
#| out-height: "300px"
x <- mvtnorm::rmvnorm(n = 1e3, mean = c(0,0), sigma = matrix(c(4,2,2,3), ncol = 2))
d <- as.data.frame(x)
d$density <- mvtnorm::dmvnorm(x = d)
library(plotly)
plot_ly(d, x = ~ V1, y = ~ V2, z = ~ density,
marker = list(color = ~ density,
showscale = TRUE)) |>
add_markers()
# Chunk 8: fig-mvnn
#| echo: false
#| label: fig-mvnn
#| fig-cap: "Joint distribution of some skewed variables"
#| out-width: "100%"
#| out-height: "300px"
op <- list(xi=c(0,1), Psi=matrix(c(2,2,2,3), 2, 2), lambda=c(6, -1.5))
rnd <- sn::rmsn(1e3, dp=sn::op2dp(op,"SN"))
d<-as.data.frame(rnd)
d$density <- mvtnorm::dmvnorm(x = d)
plot_ly(d, x = ~ V1, y = ~ V2, z = ~ density,
marker = list(color = ~ density,
showscale = TRUE)) |>
add_markers()
# Chunk 9: fig-bivnon
#| label: fig-bivnon
#| fig-cap: "Contour plot for a non-normal bivariate distribution. Marginal distributions of each variable are presented along each axis"
#| echo: false
p1 <- ggplot(d,aes(x=V1,y=V2))+
geom_point(alpha=.2)+
geom_density_2d()
ggExtra::ggMarginal(p1, type="histogram")
# Chunk 10
#| echo: false
cov(d[,1:2])
# Chunk 11: fig-bivsim
#| echo: false
#| label: fig-bivsim
#| fig-cap: "Probability distribution of simulations based on a covariance matrix (of some skewed variables). The covariance matrix contains only 2 'moments' of the variables: their scale (spread) and location (center)"
#| out-width: "100%"
#| out-height: "300px"
d <- as.data.frame(mvtnorm::rmvnorm(n = 1e3, mean = apply(d,2,mean)[1:2], sigma = cov(d[,1:2])))
d$density <- mvtnorm::dmvnorm(x = d)
plot_ly(d, x = ~ V1, y = ~ V2, z = ~ density,
marker = list(color = ~ density,
showscale = TRUE)) |>
add_markers()
# Chunk 12: fig-bivnon2
#| label: fig-bivnon2
#| fig-cap: "Contour plot for simulated data from a covariance matrix"
#| echo: false
p1 <- ggplot(d,aes(x=V1,y=V2))+
geom_point(alpha=.2)+
geom_density_2d()
ggExtra::ggMarginal(p1, type="histogram")
# Chunk 13
#| code-fold: true
library(kableExtra)
# this is just describe() but dressed up to make a nice table output (the one we see below)
stress_IQ_data |>
select(contains("IQ")) |>
describe() |>
as.data.frame() |>
rownames_to_column(var = "variable") |>
select(variable,mean,sd,skew,kurtosis) |>
kable(digits = 2) |>
kable_styling(full_width = FALSE)
# Chunk 14
stress_IQ_data |>
select(contains("IQ")) |>
multi.hist()
# Chunk 15
## GGPLOT
# temporarily reshape the data to long format to make it quicker to plot
stress_IQ_data |>
pivot_longer(IQ1:IQ5, names_to="variable",values_to="score") |>
ggplot(aes(x=score))+
geom_density()+
facet_wrap(~variable)+
theme_light()
# Chunk 16: robust estimator
model_IQ <- 'IQ =~ IQ1 + IQ2 + IQ3 + IQ4 + IQ5'
model_IQ.est <- cfa(model_IQ, data=stress_IQ_data, estimator='MLR')
# Chunk 1: setup
#| label: setup
#| include: false
source('assets/setup.R')
library(xaringanExtra)
library(tidyverse)
library(patchwork)
xaringanExtra::use_panelset()
qcounter <- function(){
if(!exists("qcounter_i")){
qcounter_i <<- 1
}else{
qcounter_i <<- qcounter_i + 1
}
qcounter_i
}
library(psych)
library(semPlot)
library(lavaan)
# Chunk 2
#| echo: false
tibble(
variable = names(read_csv("https://uoepsy.github.io/data/stressIQ.csv")),
description = c("Participant ID",
"acute stress",
"chronic stress",
"environmental stress",
"psychological stress",
"physiological stress",
"verbal ability",
"verbal memory",
"inductive reasoning",
"spatial orientiation",
"perceptual speed")
) |> gt::gt()
# Chunk 3
diagmod <- '
#IQ measurement model
IQ=~IQ1+IQ2+IQ3+IQ4+IQ5
#stress measurement model
Stress=~stress1+stress2+stress3+stress4+stress5
#structural part of model
IQ~Stress'
semPlot::semPaths(lavaanify(diagmod),rotation=1)
# Chunk 4
library(tidyverse)
library(psych)
stress_IQ_data <- read_csv("https://uoepsy.github.io/data/stressIQ.csv")
# Chunk 5
describe(stress_IQ_data) # from psych package
# Chunk 6
multi.hist(stress_IQ_data, global = FALSE) # from psych package
# Chunk 7: fig-bivnorm
#| echo: false
#| label: fig-bivnorm
#| fig-cap: "Bivariate Normal"
#| out-width: "100%"
#| out-height: "300px"
x <- mvtnorm::rmvnorm(n = 1e3, mean = c(0,0), sigma = matrix(c(4,2,2,3), ncol = 2))
d <- as.data.frame(x)
d$density <- mvtnorm::dmvnorm(x = d)
library(plotly)
plot_ly(d, x = ~ V1, y = ~ V2, z = ~ density,
marker = list(color = ~ density,
showscale = TRUE)) |>
add_markers()
# Chunk 8: fig-mvnn
#| echo: false
#| label: fig-mvnn
#| fig-cap: "Joint distribution of some skewed variables"
#| out-width: "100%"
#| out-height: "300px"
op <- list(xi=c(0,1), Psi=matrix(c(2,2,2,3), 2, 2), lambda=c(6, -1.5))
rnd <- sn::rmsn(1e3, dp=sn::op2dp(op,"SN"))
d<-as.data.frame(rnd)
d$density <- mvtnorm::dmvnorm(x = d)
plot_ly(d, x = ~ V1, y = ~ V2, z = ~ density,
marker = list(color = ~ density,
showscale = TRUE)) |>
add_markers()
# Chunk 9: fig-bivnon
#| label: fig-bivnon
#| fig-cap: "Contour plot for a non-normal bivariate distribution. Marginal distributions of each variable are presented along each axis"
#| echo: false
p1 <- ggplot(d,aes(x=V1,y=V2))+
geom_point(alpha=.2)+
geom_density_2d()
ggExtra::ggMarginal(p1, type="histogram")
# Chunk 10
#| echo: false
cov(d[,1:2])
# Chunk 11: fig-bivsim
#| echo: false
#| label: fig-bivsim
#| fig-cap: "Probability distribution of simulations based on a covariance matrix (of some skewed variables). The covariance matrix contains only 2 'moments' of the variables: their scale (spread) and location (center)"
#| out-width: "100%"
#| out-height: "300px"
d <- as.data.frame(mvtnorm::rmvnorm(n = 1e3, mean = apply(d,2,mean)[1:2], sigma = cov(d[,1:2])))
d$density <- mvtnorm::dmvnorm(x = d)
plot_ly(d, x = ~ V1, y = ~ V2, z = ~ density,
marker = list(color = ~ density,
showscale = TRUE)) |>
add_markers()
# Chunk 12: fig-bivnon2
#| label: fig-bivnon2
#| fig-cap: "Contour plot for simulated data from a covariance matrix"
#| echo: false
p1 <- ggplot(d,aes(x=V1,y=V2))+
geom_point(alpha=.2)+
geom_density_2d()
ggExtra::ggMarginal(p1, type="histogram")
# Chunk 13
#| code-fold: true
library(kableExtra)
# this is just describe() but dressed up to make a nice table output (the one we see below)
stress_IQ_data |>
select(contains("IQ")) |>
describe() |>
as.data.frame() |>
rownames_to_column(var = "variable") |>
select(variable,mean,sd,skew,kurtosis) |>
kable(digits = 2) |>
kable_styling(full_width = FALSE)
# Chunk 14
stress_IQ_data |>
select(contains("IQ")) |>
multi.hist()
# Chunk 15
## GGPLOT
# temporarily reshape the data to long format to make it quicker to plot
stress_IQ_data |>
pivot_longer(IQ1:IQ5, names_to="variable",values_to="score") |>
ggplot(aes(x=score))+
geom_density()+
facet_wrap(~variable)+
theme_light()
# Chunk 16: robust estimator
model_IQ <- 'IQ =~ IQ1 + IQ2 + IQ3 + IQ4 + IQ5'
model_IQ.est <- cfa(model_IQ, data=stress_IQ_data, estimator='MLR')
# Chunk 17
fitmeasures(model_IQ.est)[c("rmsea.robust","srmr","cfi.robust","tli.robust")]
# Chunk 18: check mods
modindices(model_IQ.est, sort=T) |> head()
model2_IQ <- '
IQ=~IQ1+IQ2+IQ3+IQ4+IQ5
IQ1~~IQ2
'
model2_IQ.est <- cfa(model2_IQ, data=stress_IQ_data, estimator='MLR')
fitmeasures(model2_IQ.est)[c("rmsea.robust","srmr","cfi.robust","tli.robust")]
summary(model2_IQ.est, standardized=T)
fitmeasures(model2_IQ.est)[c("rmsea.robust","srmr","cfi.robust","tli.robust")]
library(lavaan)
library(semPlot)
# specify the model
model_stress <- 'Stress =~ stress1 + stress2 + stress3 + stress4 + stress5'
# estimate the model - cfa will automatically switch to a categorical estimator if we mention that our five variables are ordered-categorical, using the 'ordered' function
model_stress.est <-
cfa(model_stress, data=stress_IQ_data,
ordered=c('stress1','stress2','stress3','stress4','stress5'))
# inspect the output
fitmeasures(model_stress.est)[c("rmsea","srmr","cfi","tli")]
summary(model_stress.est, standardized=TRUE)
fitmeasures(model_stress.est)
# inspect the output
fitmeasures(model_stress.est)[c("rmsea.robust","srmr","cfi.robust","tli.robust")]
summary(model_stress.est, standardized=TRUE)
fitmeasures(SEM_model.est)[c("rmsea.robust","srmr","tli.robust","cfi.robust")]
SEM_model <- '
#IQ measurement model
IQ =~ IQ1 + IQ2 + IQ3 + IQ4 + IQ5
IQ1 ~~ IQ2
IQ4 ~~ IQ5
#stress measurement model
Stress =~ stress1 + stress2 + stress3 + stress4 + stress5
#structural part of model
IQ ~ Stress
'
SEM_model.est <- sem(SEM_model, data=stress_IQ_data,
ordered=c('stress1','stress2','stress3','stress4','stress5'),
estimator="WLSMV")
fitmeasures(SEM_model.est)[c("rmsea.robust","srmr","tli.robust","cfi.robust")]
Here's our first model:
```{r}
fitmeasures(SEM_model.est)[c("rmsea.scaled","srmr","tli.robust","cfi.robust")]
```
fitmeasures(SEM_model.est)[c("rmsea.scaled","srmr","tli.robust","cfi.robust")]
fitmeasures(SEM_model.est)[c("rmsea.scaled","srmr","tli.robust","cfi.robust")]
fitmeasures(SEM_model.est)
fitmeasures(SEM_model.est)[c("rmsea.scaled","srmr","tli.scaled","cfi.scaled")]
SEM_model2 <- '
#IQ measurement model
IQ =~ IQ1 + IQ2 + IQ3 + IQ4 + IQ5
IQ1 ~~ IQ2
IQ4 ~~ IQ5
#stress measurement model
Stress =~ stress1 + stress2 + stress3 + stress4 + stress5
#structural part of model
Stress ~ IQ
'
SEM_model.est2 <- sem(SEM_model2, data=stress_IQ_data,
ordered = c('stress1', 'stress2', 'stress3', 'stress4', 'stress5'),
estimator="WLSMV")
fitmeasures(SEM_model.est2)[c("rmsea.scaled","srmr","tli.scaled","cfi.scaled")]
junk::uoepsy_col()
